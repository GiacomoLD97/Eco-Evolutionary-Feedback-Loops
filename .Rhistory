# get the sequnce of fitting parameters
seqmat <- expand.grid(n = nseq, m = mseq, r = rseq, p = pseq, iter = 1:500) %>% data.frame() %>% as_tibble() %>% slice(sample(1:nrow(.), nrow(.), replace = FALSE))
# number of fits per thread
neach <- 25
# creat the fit squence
chunk_seq <- seq(1, nrow(seqmat), by = neach)
# simulate in parallel, with each thread running 100 sims at a time
res <- foreach(kind = 1:length(chunk_seq), .combine = c, .inorder = FALSE)%dopar%{
# the dataframe to store the results
outcome_df<-NULL
start <- chunk_seq[kind]
end <- ifelse(kind == length(chunk_seq), nrow(seqmat), chunk_seq[kind+1]-1)
for(j in start:end){
# print(paste0(j," of ",start,"-",end))
my_res <- withTimeout(run_single_sim(j, seqmat, C1, C2, max_count), timeout=Inf, elapsed = max_timeout, onTimeout = "silent")
if(!is.null(my_res)){
outcome_df <- outcome_df %>% bind_rows(my_res)
}
}
write_csv(outcome_df, paste0(out_folder,"/file_", kind + offset, ".csv"))
return(NA)
}
here()
rm(list=ls())
gc()
library(numDeriv)
library(R.utils)
library(Rglpk)
library(doMC)
library(combinat)
library(viridis)
library(doParallel)
library(RColorBrewer)
library(scales)
library(deSolve)
library(reshape2)
library(gridExtra)
library(igraph)
library(tidyverse)
library(here)
here()
here::i_am("Code/Simulated Experiments/1_simulation_code.R")
here:("Code/Simulated Experiments/1_simulation_code.R")
here("Code/Simulated Experiments/1_simulation_code.R")
here::i_am("Code/Simulated Experiments/1_simulation_code.R")
here("Code", "Simulated Experiments", "1_simulation_code.R")
# Assuming you have downloaded the GitHub Repo and opened the project
# Using "here" to source relative directories
here()
here("Code", "Simulated Experiments", "1_simulation_code.R")
setwd(here("Code", "Simulated Experiments", "1_simulation_code.R"))
getwd()
#Assuming you have downloaded the GitHub Repo, using here to source relative directories
here()
here::i_am("Code/Simulated Experiments/1_simulation_code.R")
source(here("Code", "Simulated Experiments", "0_functions_replicator.R"))
here("data", "simulation_results")
out_folder <- here("Data", "Simulation_results")
offset <- 1000000
have_files <- list.files(out_folder)
if(length(have_files) > 0){
offset <- max(as.numeric(gsub("\\.csv", "", gsub("file_", "", have_files))))+10000000
}else{
offset <- 0
}
# Assuming you have downloaded the GitHub Repo and opened the project
# Using here to source relative directories
here()
here("Code", "Simulated Experiments", "0_functions_replicator.R")
# number of threads
nthreads <- 12
registerDoParallel(nthreads)
# threashold to prune the simulations and dynamics.
THRESH_sim <<- THRESH_prune <<- THRESH <<- 1e-7
# set the range for memory (determines Q)
pseq <- round(seq(0.25, 0.99, length=25), 3)
# set the range for the relatedness of phenotypes (determines H)
rseq <- round(seq(0, 1, length=25), 3)
# specify the two extremes -- C1 is perfectly transitive, C2 perfectly intransitive
C1 <- list(rbind(c(0.5,1,1), c(0,0.5,1), c(0,0,0.5)),
rbind(c(0.5, 1,1,1,1), c(0,0.5, 1, 1, 1), c(0,0,0.5, 1,1), c(0,0,0,0.5,1), c(0,0,0,0,0.5)),
rbind(c(0.5, 1,1,1,1,1,1),c(0,0.5,1,1,1,1,1),c(0,0,0.5,1,1,1,1),c(0,0,0,0.5,1,1,1),c(0,0,0,0,0.5,1,1),c(0,0,0,0,0,0.5,1),c(0,0,0,0,0,0,0.5)))
C2 <- list(rbind(c(0.5,0,1), c(1, 0.5, 0), c(0, 1, 0.5)),
rbind(c(0.5, 1, 0, 1, 0), c(0, 0.5, 1, 0, 1), c(1, 0, 0.5, 1, 0), c(0,1,0, 0.5, 1), c(1, 0, 1, 0, 0.5)),
rbind(c(0.5,1,0,0,1,1,0), c(0,0.5, 1, 1, 0, 0, 1), c(1, 0, 0.5, 1,0,0,1), c(1,0,0,0.5,1,0,1), c(0,1,1,0,0.5,1,0), c(0,1,1,1,0,0.5,0), c(1,0,0,0,1,1,0.5)))
# max number of fitting attempts and timeoue
max_count <- 200
max_timeout <- 60*2
kind <- j <- i <- z <- 1
nseq <- c(3,5) #,10,15)
mseq <- c(3,5,7)
# get the sequnce of fitting parameters
seqmat <- expand.grid(n = nseq, m = mseq, r = rseq, p = pseq, iter = 1:500) %>% data.frame() %>% as_tibble() %>% slice(sample(1:nrow(.), nrow(.), replace = FALSE))
# number of fits per thread
neach <- 25
# creat the fit squence
chunk_seq <- seq(1, nrow(seqmat), by = neach)
# simulate in parallel, with each thread running 100 sims at a time
res <- foreach(kind = 1:length(chunk_seq), .combine = c, .inorder = FALSE)%dopar%{
# the dataframe to store the results
outcome_df<-NULL
start <- chunk_seq[kind]
end <- ifelse(kind == length(chunk_seq), nrow(seqmat), chunk_seq[kind+1]-1)
for(j in start:end){
# print(paste0(j," of ",start,"-",end))
my_res <- withTimeout(run_single_sim(j, seqmat, C1, C2, max_count), timeout=Inf, elapsed = max_timeout, onTimeout = "silent")
if(!is.null(my_res)){
outcome_df <- outcome_df %>% bind_rows(my_res)
}
}
write_csv(outcome_df, paste0(out_folder,"/file_", kind + offset, ".csv"))
return(NA)
}
source("~/Documents/GitHub/Eco-Evolutionary Feedback Loops/Code/Simulated Experiments/1_simulation_code.R", echo = TRUE)
here()
here::i_am()
##### This files runs the replicator model simulations at two levels of intraspecific intransitivity
### 1. Load required packages ####
# Install packages before loading if needed
library(numDeriv)
library(R.utils)
library(Rglpk)
library(doMC)
library(combinat)
library(viridis)
library(doParallel)
library(RColorBrewer)
library(scales)
library(deSolve)
library(reshape2)
library(gridExtra)
library(igraph)
library(tidyverse)
### 2. Set Relative Directories to execute script ####
# Assuming you have downloaded the GitHub Repo and opened the project
# Using here to source relative directories
here()
##### This files runs the replicator model simulations at two levels of intraspecific intransitivity
### 1. Load required packages ####
# Install packages before loading if needed
library(numDeriv)
library(R.utils)
library(Rglpk)
library(doMC)
library(combinat)
library(viridis)
library(doParallel)
library(RColorBrewer)
library(scales)
library(deSolve)
library(reshape2)
library(gridExtra)
library(igraph)
library(tidyverse)
library(here)
### 2. Set Relative Directories to execute script ####
# Assuming you have downloaded the GitHub Repo and opened the project
# Using here to source relative directories
here()
here::i_am("Code/Simulated Experiments/1_simulation_code.R")
source(here("Code", "Simulated Experiments", "0_functions_replicator.R"))
out_folder <- here("Data", "Simulation_results")
# specify the directory to save results to
dir.create(out_folder, showWarnings = FALSE)
offset <- 1000000
# get the offset in case we've already written some files
have_files <- list.files(out_folder)
if(length(have_files) > 0){
offset <- max(as.numeric(gsub("\\.csv", "", gsub("file_", "", have_files))))+10000000
}else{
offset <- 0
}
### 3. Initialize Simulation run ####
# number of threads
nthreads <- 12
registerDoParallel(nthreads)
# threashold to prune the simulations and dynamics.
THRESH_sim <<- THRESH_prune <<- THRESH <<- 1e-7
# set the range for memory (determines Q)
pseq <- round(seq(0.25, 0.99, length=25), 3)
# set the range for the relatedness of phenotypes (determines H)
rseq <- round(seq(0, 1, length=25), 3)
# specify the two extremes -- C1 is perfectly transitive, C2 perfectly intransitive
C1 <- list(rbind(c(0.5,1,1), c(0,0.5,1), c(0,0,0.5)),
rbind(c(0.5, 1,1,1,1), c(0,0.5, 1, 1, 1), c(0,0,0.5, 1,1), c(0,0,0,0.5,1), c(0,0,0,0,0.5)),
rbind(c(0.5, 1,1,1,1,1,1),c(0,0.5,1,1,1,1,1),c(0,0,0.5,1,1,1,1),c(0,0,0,0.5,1,1,1),c(0,0,0,0,0.5,1,1),c(0,0,0,0,0,0.5,1),c(0,0,0,0,0,0,0.5)))
C2 <- list(rbind(c(0.5,0,1), c(1, 0.5, 0), c(0, 1, 0.5)),
rbind(c(0.5, 1, 0, 1, 0), c(0, 0.5, 1, 0, 1), c(1, 0, 0.5, 1, 0), c(0,1,0, 0.5, 1), c(1, 0, 1, 0, 0.5)),
rbind(c(0.5,1,0,0,1,1,0), c(0,0.5, 1, 1, 0, 0, 1), c(1, 0, 0.5, 1,0,0,1), c(1,0,0,0.5,1,0,1), c(0,1,1,0,0.5,1,0), c(0,1,1,1,0,0.5,0), c(1,0,0,0,1,1,0.5)))
# max number of fitting attempts and timeoue
max_count <- 200
max_timeout <- 60*2
kind <- j <- i <- z <- 1
nseq <- c(3,5) #,10,15)
mseq <- c(3,5,7)
# get the sequnce of fitting parameters
seqmat <- expand.grid(n = nseq, m = mseq, r = rseq, p = pseq, iter = 1:500) %>% data.frame() %>% as_tibble() %>% slice(sample(1:nrow(.), nrow(.), replace = FALSE))
# number of fits per thread
neach <- 25
# creat the fit squence
chunk_seq <- seq(1, nrow(seqmat), by = neach)
### 4. Run the Simulation ####
# simulate in parallel, with each thread running 100 sims at a time
res <- foreach(kind = 1:length(chunk_seq), .combine = c, .inorder = FALSE)%dopar%{
# the dataframe to store the results
outcome_df<-NULL
start <- chunk_seq[kind]
end <- ifelse(kind == length(chunk_seq), nrow(seqmat), chunk_seq[kind+1]-1)
for(j in start:end){
# print(paste0(j," of ",start,"-",end))
my_res <- withTimeout(run_single_sim(j, seqmat, C1, C2, max_count), timeout=Inf, elapsed = max_timeout, onTimeout = "silent")
if(!is.null(my_res)){
outcome_df <- outcome_df %>% bind_rows(my_res)
}
}
write_csv(outcome_df, paste0(out_folder,"/file_", kind + offset, ".csv"))
return(NA)
}
### 2. Set Relative Directories to execute script ####
here()
##### This files combines all of the individual files output by 1_simulation_code.R
### 1. Load required packages ####
# Install packages before loading if needed
library(tidyverse)
library(here)
### 2. Set Relative Directories to execute script ####
here()
here::i_am("Code/Simulated Experiments/2_combine_files.R")
# specify the folder to combine
out_folder <- here("Data", "Simulation_results")
### 3. Combine the files ####
# now list all the files and merge
my_files <- list.files(out_folder)
all_files <- tibble()
for(i in 1:length(my_files)){
print(c(i, length(my_files)))
all_files <- all_files %>% bind_rows(read_csv(paste0(out_folder, "/", my_files[i]), show_col_types = FALSE))
}
# now list all the files and merge
my_files <- list.files(out_folder)
my_files
paste0(out_folder, ".csv")
here()
here::i_am("Code/Simulated Experiments/3_analyze_plot_results.R")
here("Data", "Simulation_results.csv")
##### This files plots the relative benefit between two levels of intraspecific intransitivity
### 1. Load required packages ####
# Install packages before loading if needed
library(viridis)
library(tidyverse)
library(here)
### 2. Set Relative Directories to execute script ####
here()
here::i_am("Code/Simulated Experiments/3_analyze_plot_results.R")
# read in the data
dt <- read_csv(
here("Data", "Simulation_results.csv")
)
### 3. Plot the results ####
# spread the data and calculate the difference in final intransitivity between the two scenarios
relben <- dt %>%
select(id, sim, iter, p, m, n_init, rho, model, init_bab_sum, final_bab_sum) %>%
spread(model, final_bab_sum) %>%
mutate(intran =(intran - tran))
# plot
(g1 <- ggplot(relben, aes(x = p, y = rho, z = intran)) +
stat_summary_2d(bins =  c(23,23),color = NA, fun = mean) +
labs(title = "", x = "Phenotypic memory (p)", y = expression(paste("Phenotypic similarity (",tau,")")), fill = "Relative\nBenefit\n") +
theme_classic()+
facet_grid(n_init~m)+
scale_fill_viridis(option = "A"))
here()
library(tidySEM)
library(lavaan)
library(tidyverse)
library(here)
here()
here::i_am("Code/Path Analysis/4_path_analysis.R")
# read in the data
dt <- read_csv(
here("Data", "Simulation_results.csv")
)
# read in the data
dt <- read_csv(
here("Data", "Simulation_results.csv")
)
relben <- dt %>%
select(id, sim, iter, p, m, n_init, rho, model, n_final, init_bab_sum, final_bab_sum) %>%
mutate(intran = ifelse(model == "intran", 1, 0)) %>%
rename(intran_within = intran) %>%
rename(intran_between = final_bab_sum)
relben_thous <- relben[sample(nrow(relben), 100000), ]
relben_mill <- relben[sample(nrow(relben), 1000000), ]
eigenvalues <- eigen(cor(relben))$values
eigenvalues <- eigen(cor(relben_thous))$values
View(relben_thous)
### 4. Exploratory Factor Analysis ####
num <- relben_thous %>% select(-c(model))
View(num)
eigenvalues <- eigen(cor(num))$values
print(eigenvalues)
scree_plot <- data.frame(
eigenvalues = eigen(cor(num))$values,
component = 1:length(eigen(cor(num))$values)
)
plot(scree_plot$component, scree_plot$eigenvalues, type = "b",
xlab = "Component Number", ylab = "Eigenvalue",
main = "Scree Plot")
efa_result <- fa(r = num, nfactors = 7, rotate = "varimax")
??fa
efa_result <- efa(r = num, nfactors = 7, rotate = "varimax")
efa_result <- efa(r = num, nfactors = 2, rotate = "varimax")
?efa
num <- relben_thous %>% select(-c(model, id, sim))
num <- relben_thous %>% select(-c(model, id, sim, iter, init_bab_sum))
eigenvalues <- eigen(cor(num))$values
print(eigenvalues)
scree_plot <- data.frame(
eigenvalues = eigen(cor(num))$values,
component = 1:length(eigen(cor(num))$values)
)
plot(scree_plot$component, scree_plot$eigenvalues, type = "b",
xlab = "Component Number", ylab = "Eigenvalue",
main = "Scree Plot")
abline(h = 1, col = "red", lty = 2)
efa_result <- efa(r = num, nfactors = 5, rotate = "varimax")
print(efa_result)
m2 <- '
intran_between ~ rho + p + m
system_arch =~ intran_within + rho + p + m
system_intran =~ intran_between + intran_within
n_final ~ system_intran + system_arch + n_init
'
fit2 <- sem(m2, data = relben_mill)
graph_sem(model = fit2)
m2 <- '
intran_between ~ rho + p + m
system_intran =~ intran_between + intran_within
n_final ~ system_intran + n_init
'
fit2 <- sem(m2, data = relben_mill)
graph_sem(model = fit2)
fit2 <- cfa(m2, data = relben_mill)
m2 <- '
system_intran ~ rho + p + m
system_intran =~ intran_between + intran_within
n_final ~ system_intran + n_init
'
fit2 <- cfa(m2, data = relben_mill)
m2 <-
'  system_intran =~ intran_between + intran_within
system_intran ~ rho + p + m        # regress the latent on exogenous
n_final ~ system_intran + n_init
'
fit2 <- cfa(m2, data = relben_mill)
graph_sem(model = fit2)
summary(fit2, fit.measures = TRUE)
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + p
intran_within ~  m
n_final ~ intran_between + n_init
'
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + p
intran_within ~  m
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
modindices(fit)
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + p
intran_within ~  m
n_final ~ intran_between + n_init + p
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
modindices(fit)
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + p
intran_within ~  m
n_final ~ intran_between + n_init + intran_within
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
modindices(fit)
m1 <-   '
# regressions
intran_between ~ intran_within + p + rho + m
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
m1 <-   '
# regressions
intran_within ~ m
intran_between ~ intran_within + p + rho
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
m1 <-   '
# regressions
intran_within ~  m
intran_between ~ intran_within + n_init + p + rho
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
modindices(fit)
m1 <-   '
# regressions
intran_within ~  p + rho
intran_between ~ intran_within + n_init + m
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + m + p + rho
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
modindices(fit)
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + m + p + rho
n_final ~ intran_between + n_init
intran_between ~~ n_final
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
m1 <-   '
# regressions
intran_between ~ intran_within + m + p + rho
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
m1 <-   '
# regressions
intran_between ~ intran_within + n_init + m + p + rho
n_final ~ intran_between + n_init
'
fit <- sem(m1, data = relben_mill)
graph_sem(model = fit)
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
modindices(fit)
#Refined path diagram
semPaths(
object = fit,
what = "path",
whatLabels = "par",
style = "ram",
layout = "tree",
rotation = 2,
sizeMan = 7,
sizeLat = 7,
color = "lightgray",
edge.label.cex = 1.2,
label.cex = 1.3
)
library(semPlot)
#Refined path diagram
semPaths(
object = fit,
what = "path",
whatLabels = "par",
style = "ram",
layout = "tree",
rotation = 2,
sizeMan = 7,
sizeLat = 7,
color = "lightgray",
edge.label.cex = 1.2,
label.cex = 1.3
)
#Model fit and variable coefficients
summary(fit, fit.measures = TRUE, rsquare = TRUE, stand = TRUE)
fit_indices <- fitMeasures(fit, c("cfi", "tli", "rmsea", "srmr"))
fit_indices
semPaths(
fit,
what = "path",
whatLabels = "par",
style = "ram",
layout = "tree",
rotation = 2,
sizeMan = 7,
sizeLat = 7,
color = "lightgray",
edge.label.cex = 1.2,
label.cex = 1.3,
exoCov = FALSE,     # hide covariances between exogenous variables
nCharNodes = 0      # show full variable names
)
